# I

АРХИТЕКТУРА - описание возможностей программирования,
системы адресации, команд, орг-и памяти и т.д.
А. определяет принципы действия, инф. связи и взаимное соед-е
логических узлов компьютера.
Совместимость компьютеров обесп-ся общностью архитектуры.

Орг-я вычислительной системы - набор устройств и способов их
вз-д-я для реализации архитектуры:
технологии реализаии памяти, шины, связующие устройства, и
воплощение процессора в кристалле кремния.

### Уровни архитектуры:

* Языки выч. устройств - компиляторы и библиотеки 
* язык ассемблера - ассемблер, линкер, отладчик
* ОС - системное прог-е: ОЗУ, шины, ЦП
* машинный код - вн. шины, тракт данных, АЛУ
* микрокод процессора 
* цифровая логика - лог. вентили и схемы
* физический уровень

### Примеры архитектур:

* фон Неймана - АЛУ+поток данных+УУ+программа (поток команд)
* многопроцессорная - то же, но несколько АЛУ, 
	потоков данных и программ
* многомашинная - то же, но у каждого АЛУ своя РАМ
	с параллельными процессорами - УУ одно, АЛУ несколько, 
	т.е. может обрабатываться много данных по одной команде.

# II
	
### Этапы автоматизации вычислений:

* 1642-1945 механика
* 1945-55 ламповые ЭВМ
* 55-65 транзисторы
* 65-80 интегральные схемы
* 1980-2000е? сверхбольшие и.с.
* 2000е-... микрокомпьютеры, "невидимые" компьютеры

	TODO?

# III
	
	/- ЦП (регистры - АЛУ - УУ)
	|
	|- основная память 
	|
	|- IO-устройства
	|
	... шина

	Цикл работы тракта данных:
		
    вх. регистр 
	АЛУ			регистры	                    выходной
	A+B/.../.../A/.../B/...----> A -> \          регистр
	 |		                |         АЛУ -> A+B  АЛУ
	 |                       \-> B -> /       v   
	  \______________________________________/
	 
существует два вида команд: 

рег.-рег.:  ``` ADD AX, BX ```

рег.-память: ``` MOV AX, m ```
	 
### Алгоритм работы ЦП:

1. вызвать след. команду из памяти, перенести в регистр команд
2. сменить положение счётчика команд
3. определить тип команды
4. определить операнды и положение слова из памяти, если используется
5. выполнить команду
6. записать результат
7. goto 1

Интерпретатор - программа, имитирующая работу ЦП
	
* разбивает команды на основные инструкции
* позволяет исправить реализацию команды,
	 			компенсировать ошибки 
		    		аппаратного обеспечения программно
	   			и добавить новые команды 
	   			с минимальными затратами
* даёт возможность разработки, проверки 
	  и документирования сложных команд
	
### Примеры реализации команд через микрокоманды:


```ADD``` = ```INC```

```SUB``` = ```DEC```

```MUL``` = ```INC*```

```MUL``` на степень двойки = ```SHL```

```DIV``` на степень двойки = ```SHR```

float-операции - через целые числа

циклы - ```GOTO```

вызовы подпрограмм - ```GOTO```

работа со строками - см. циклы

        
#### АППАРАТНОЕ И ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ЛОГИЧЕСКИ ЭКВИВАЛЕНТНО.
        
Любая команда или операция, выполняемая одним, 
        моделируема другим.
        Почему же тогда они разделены? 
        Стоимость, быстродействие, надёжность и частота изменений.
        
### Разновидности процессоров:

* Complex instruction set computer - CISC, 
     	полный набор команд (x86, Motorola MC68K)
  
* Reduced -//- - RISC, 
        упрощённый в пользу б-д-я набор команд 
        (SPARC, MIPS, ARM, Atmel AVR)
        
### Принципы проектирования:

 * все команды выполняются ПО
 * исполняемых команд в секунду должно быть как можно больше
 * команды должнв легко декодироваться
 * к памяти обращаются только команды загрузки и сохранения
 * много регистров
        
Таксономия Флинна:

Разделяет арх. ЭВМ по наличию параллелизма (single/multiple) 
в потоках данных (data) и команд (instruction).
        

#### SISD: 

###### Конвейерные процесссоры
	Z3, Intel Pentium 4, Atmel AVR, PIC

	выборка команд - декодирование - выборка операндов - 
    выполнение команд - обратная запись (результатов)
    
    1
    12
    123
    1234
    12345
    23456
    .
    .
    .
    

###### Суперскалярные процессоры - 
	SPARC, ARM, MIPS, Pentium после 4, 
	AMD Athlon, Ryzen, Эльбрус (земля ему санкциями)
	отличаются лишь тем, 
	что способны имитировать НЕСКОЛЬКО таких конвейеров
	либо один конвейер, но с несколькими блоками 
	выполнения команды.    
#### SIMD - матричные компьютеры: 
	ILLIAC IV, позднее Intel Core, современные GPU...    
#### MISD - конвейерные ЭВМ
        
#### MIMD - мультипроцессоры: 
	Intel Xeon, AMD Opteron, Threadripper 
Схема реализации памяти - NUMA (non-uniform memory access), время доступа опр-ся раположением относительно процессора.
        
### Оптимизация по быстродействию:

  - отказ от универсальности - замещение универсальных инструкций 
        	на подходящие конкретной ситуации 
        	(MUL на степень двойки можно заменить SHL)
  - уменьшение кол-ва передач управления в программе за счёт преобразования if-переходов, 
        	после которого ELSE будет срабатывать чаще и перемещения условий общего характера к началу разветвления на переходы

  - оптимизация циклов, в т.ч. вынесение наружу констант,
        	разворачивание циклов (TODO ?) 
        и соединение выполняемых одинаковое 
        	кол-во раз циклов в один ("сжатие")
  - максимальное использование доступных регистров
  - использование специфических для процессора инструкций
        
# IV
	
см. схему из I

основная память разделяется на RAM и ROM

TODO адрес ячейки памяти

Порядок байтов:

* big-endian - старшие байты по младшему адресу 
		(TCP/IP, формат PNG): 
		```29531=73 5B```
* little-endian (x86): 
		```29531=5B 73```
* bi-endian - переключаемый формат 
		(ARM, PowerPC, MIPS, PA-RISC...)



Примеры разбиения адреса:

* 8 бит, прямой порядок - ```0A 0B 0C 0D```
* 8 бит, обратный порядок - ```0D 0C 0B 0A```
* 16 бит, прямой порядок - ```0A0B 0C0D```
* 16 бит, обратный порядок - ```0C0D 0A0B```
	
Прямой порядок удобнее для человека, но обратный упрощает 
	реализацию арифметики, адресацию 
		и изменение размера слова (16-32-64 бита)
	
	
Кэш (сверхоперативная память) -
	буфер с быстрым доступом, содержащий информацию, 
		чаще всего запрашиваемую процессором.
	
	
Архитектура фон Неймана, закон Мура

$c$ - среднее время доступа к кэшу

$m$ - среднее время доступа к основной памяти

$h$ - вероятность кэш-промаха

$t=c+hm$ - среднее время доступа к данным

	
### Алгоритмы замещения:
	
- LRU - давно неиспользуемых
- LFU - наименее часто используемых

	и т.д.
	
TODO политики обратной записи
	
формат записи: тэг-данные-флаги
	
TODO слайд 17
	
### Уровни кэша:
	
- L1 часть процессора, Гардвардская архитектура, 16-64 кБ
- L2 отдельный набор микросхем, 512 КБ - 1-12 мБ
- L3 в общем пользовании, >24 кБ
- L4 только для многопроцессорных систем

# VI
### Откуда вообще берутся ошибки?
- скачки напряжения при чтении-записи памяти
- механические повреждения дисков и шин
- ошибка приёма-передачи данных сети

### Что с ними делать после обнаружения?
- на канальном и транспортном уровнях - 
		запросить передачу ещё раз
- в системах потокового мультиммедиа - 
		отбросить повреждённый блок
- исправить (на физическом уровне)
	
### Код коррекции/контроля ошибок
Кодовое слово - пос-ть из N бит, 
		содерж-я K бит данных и R контрольных разрядов

Бит чётности: 01011101 + 1

Кодовое пространство - множество кодовых слов (векторов), 
	 	применимых в системе кодирования.
	 	(2^N при длине N бит, допустимых комбинаций - 2^K)

Расстояние по Хэммингу - кол-во отличных позиций 
	 	двух кодовых векторов (между 0110 и 0011 расст-е = 2)

Минимальное кодовое расст-е - наименьшее к.р. между двумя
	 	допустимыми кодами в данной системе кодирования.

Избыточность кода - отношение R/N

###### Пример с битом чётности:
	 	N=3, K=2, R=1
	 	допустимы слова 000 011 101 110
	 	d=2
	 	Ошибку находит, но не исправляет
	 	R/N=1/3

###### Бит троекратного повторения:
	 	N=3, K=1, R=2
	 	допустимы слова 000 111
	 	d=3
	 	Ошибку исправляет
	 	R/N=2/3, избыточен
	 
Обнаружение и исправление ошибок:

Пусть ```g``` - количество ошибок
```d>=g+1``` нужно для обнаружения ошибок
```d>=2g+1``` - для исправления

###### Пример: 

Пусть допустимы $0000000000, 0000011111, 
1111100000, 1111111111$.

$d=5$; для слова $0000000111$ при $g<=2$ ошибки можно и исправить, но при $g>2$ - только обнаружить.

Нижний предел кол-ва контрольных разрядов 
		 	для одиночных ошибок - $K+R+1<=2^R$
	
### (7,4)-код Хэмминга
$N=7, K=4, R=3, d=3$

число единиц в кодовой пос-ти чётно, кол-во контролируемых ошибок - $d-1$,	исправляемых - $floor((d-1)/2)$

Семейство кодов Хэмминга - ($2^R-1$, $2^R-R-1$)
Пусть $d_{1,2,3,4}$ - данные. 

$r_{1}=d^1+d^2+d^4, r_{2}=d^1+d^3+d^4, r_{3}=d^2+d^3+d^4$ - контрольные биты

Кодовое слово имеет вид "$r_{1} r_{2} d^1 r_{3} d^2 d^3 d^4$",
		где r занимают позиции, соотв. степеням двойки
		ПРИ СЧЁТЕ СЛЕВА НАПРАВО

### Проверочная матрица H

\begin{pmatrix}
     1 & 0 & 1 & 0 & 1 & 0 & 1 \\ 
     0 & 1 & 1 & 0 & 0 & 1 & 1 \\
     0 & 0 & 0 & 1 & 1 & 1 & 1
 \end{pmatrix}

Если в принятом слове $V$ есть не больше одной ошибки 
		и вектор (синдром) $S=H*(V)^T$ имеет вид 
$\begin{pmatrix}
     0\\ 
     0\\
     0
 \end{pmatrix}$, ошибок нет, иначе S выдаёт ошибочную позицию (необходимо найти S как столбец таблицы)

$$ V = 0111100 $$

$$S=H*(V)^T =  \begin{pmatrix}
     1 & 0 & 1 & 0 & 1 & 0 & 1 \\ 
     0 & 1 & 1 & 0 & 0 & 1 & 1 \\
     0 & 0 & 0 & 1 & 1 & 1 & 1
 \end{pmatrix} * 0111100^\intercal = \begin{pmatrix}
     0\\ 
     0\\
     0
 \end{pmatrix}
$$

$V = 0101100 => S = \begin{pmatrix}
     1\\ 
     1\\
     0
 \end{pmatrix} =>$ 3-й бит ошибочен
	TODO
	VII VIII
